##########################################################################
# 足し算ゲームとほぼ同様です。
# 桁数と、演算の種類をリクエストするようになっています。
# 簡単なものを創って、より高機能のものへと、拡張していくと良いです。
##########################################################################

# 実行した時刻等によって、異なった乱数となるように乱数の種を播きます。
# (いつも同じ乱数にしたければ、srand 123 の様に数を指定します)
srand

# 初期化
# 繰り返し内で出現した変数は、その繰り返しの中でのみ有効となります。
# 有効範囲（スコープ）と言います。
# 繰り返しの外で出現させることにより、どの繰り返しの中でも
# これらの変数が使えるようになります。
operand1 = 0    # 第一被演算子
operand2 = 0    # 第二被演算子
operator = "+"  # 演算子（"+", "-", "*", "/")
digit    = 1    # 桁数
result   = 0    # 演算結果
answer   = 0    # 回答
correct  = 0    # 正答数

# 桁数をリクエスト
loop do
  puts "何桁の数字で挑戦しますか？ "
  puts "一桁: 1　二桁: 2　三桁: 3　四桁: 4"
  digit = gets.chomp.to_i # getsメソッドでキー入力を受け取ります。
                          # chompメソッドで改行文字を取り除きます。
                          # to_iメソッドで整数型に変換します。
  if digit.between?(1, 4) # digit が 1 ~ 4 の範囲内にあるなら、
    break                 # 繰り返しを抜けます。
  end
end

# 演算子をリクエスト
loop do
  puts "どの演算に挑戦しますか？ "
  # 足し算、引き算、掛け算、割り算 のことです。
  # 加算、減算、乗算、除算という呼び方も知っておいて欲しいです。
  puts "加算: +　減算: -　乗算: *　除算: /"
  operator = gets.chomp # getsメソッドでキー入力を受け取ります。
                        # chompメソッドで改行文字を取り除きます。

  if ["+", "-", "*", "/"].include? operator
    break               # operator が +-*/ に含まれるなら、
                        # 繰り返しを抜けます。
  end
end

correct = 0 # 10問中何問正解か数えるために、初期化します。
# 1 回目、2 回目 と表示させたいので
# 範囲オブジェクト(1..10)を使い、繰り返すところに着目してください。
(1..10).each do |n|
  # 出題処理

  #冪乗を求める演算子を使って、必要な桁数に調整します。
  #(digit == 2 なら 0 ~ 99までの乱数が得られます)
  operand1 = rand(0...10**digit)

  # 第二被演算子 operand2 が
  # 第一被演算子 operand1 と
  # 異なる数になるまで、繰り返します。
  # また 0 の割り算は定義されていないので、
  # 割り算の場合には、三項演算子(条件演算子)を用いて
  # 1からの乱数となるようにします。
  operand2 = (operator == "/" ? rand(1...10**digit) : rand(1...10**digit))

  loop do
    if operand2 == operand1
      operand2 = (operator == "/" ? rand(1...10**digit) : rand(1...10**digit))
    else
      break
    end
  end

  # Ruby では、if や case は 「式」です。
  # なので、if や case の結果を、result に代入できます。
  result =  case operator
            when "+"
              operand1 + operand2
            when "-"
              operand1 - operand2
            when "*"
              operand1 * operand2
            when "/"
              operand1 / operand2
            end

  # ゲーム名を表示するための場合分けです。
  # こう書いた方が素直です。
  # case operator
  # when "+":
  #   puts "足し算ゲーム #{i} 回目"
  # case "-":
  #   puts "引き算ゲーム #{i} 回目"
  # case "*":
  #   puts "掛け算ゲーム #{i} 回目"
  # case "/":
  #   puts "割り算ゲーム #{i} 回目"
  # end

  # 連想配列（ハッシュ）のご紹介
  # 配列が添字(数値)を指定することにより、その値を取得するものであったのに対し、
  # 連想配列は、その名称に示されるように、
  # 名称(キー)を指定することにより、その値（バリュー）を取得することが出来ます。
  game_name = { "+": "足し算", "-": "引き算", "*": "掛け算", "/": "割り算" }
  # と書いて、連想配列を設定します。
  # 連想配列から値（バリュー）を取得する為には、キーとして「:+」を指定します。
  # :+ は「シンボル」と呼ばれるものです。
  # "+" は「文字列」で、文字列操作の為の便利なメソッドを沢山もっていますが、
  # 連想配列で必要なのは、単に数値代わりとなる名前が欲しいだけですので、
  # 「牛刀をもって鶏を割く」感があります。
  # そこで登場するのが「シンボル」です。人の目から見ると、
  # 分かりやすい文字列のように見え、
  # 内部的には数値として扱われますので、計算機にも優しくなっています。
  # 実際に puts game_name[:+]と書くと「足し算」と表示されます。
  # "+" は文字列ですが、文字列から「シンボル」に変換する為には
  # to_symメソッドを用います。
  # このことをわきまえると、
  printf "%sゲーム %d 回目\n", game_name[operator.to_sym], n
  # と書けます。
  #
  # 配列は、添字として、数字をとりましたが、
  # 連想配列は文字を添字として使えるようになるので、分かりやすく便利です。
  # 連想配列（ハッシュ）は良く使われるデータ構造です。
  # どうぞ習得なさってください。

  printf "%d %c %d = ?", operand1, operator, operand2

  # 回答を受け取る
  answer = gets.chomp.to_i # getsメソッドでキー入力を受け取ります。
                           # chompメソッドで改行文字を取り除きます。
                           # to_iメソッドで整数型に変換します。

  # 正解発表と正答数のカウント
  if answer == result
    puts "正解です。"
    correct += 1           # Ruby にはインクリメント演算子はありません。
                           # 自己代入演算子で代用します。
  else
    puts "正解は、#{result} です。"
  end
end

# 総合結果発表
puts "10問中 #{correct} 問 正解"
